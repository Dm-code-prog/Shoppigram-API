// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: notifications.sql

package generated

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getAdminBotToken = `-- name: GetAdminBotToken :one
select pgp_sym_decrypt(admin_bot_encr_token, $2::text)
from web_apps
where id = $1
`

type GetAdminBotTokenParams struct {
	ID            uuid.UUID
	EncryptionKey string
}

func (q *Queries) GetAdminBotToken(ctx context.Context, arg GetAdminBotTokenParams) (interface{}, error) {
	row := q.db.QueryRow(ctx, getAdminBotToken, arg.ID, arg.EncryptionKey)
	var pgp_sym_decrypt interface{}
	err := row.Scan(&pgp_sym_decrypt)
	return pgp_sym_decrypt, err
}

const getAdminsNotificationList = `-- name: GetAdminsNotificationList :many
select admin_username, admin_chat_id
from notify_list
where web_app_id = $1
`

type GetAdminsNotificationListRow struct {
	AdminUsername pgtype.Text
	AdminChatID   int64
}

func (q *Queries) GetAdminsNotificationList(ctx context.Context, webAppID pgtype.UUID) ([]GetAdminsNotificationListRow, error) {
	rows, err := q.db.Query(ctx, getAdminsNotificationList, webAppID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAdminsNotificationListRow
	for rows.Next() {
		var i GetAdminsNotificationListRow
		if err := rows.Scan(&i.AdminUsername, &i.AdminChatID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNotificationsForOrdersAfterCursor = `-- name: GetNotificationsForOrdersAfterCursor :many
with orders_batch as (select id as order_id, created_at, readable_id, web_app_id, external_user_id
                      from orders o
                      where o.created_at >= $1
                      order by o.created_at
                      limit $2)
select orders_batch.order_id,
       orders_batch.readable_id,
       orders_batch.created_at,
       p.web_app_id,
       p.name,
       p.price,
       op.quantity,
       p.price_currency,
       u.username
from orders_batch
         join order_products op
              on orders_batch.order_id = op.order_id
         join products p on p.id = op.product_id
         join telegram_users u on external_user_id = u.external_id
`

type GetNotificationsForOrdersAfterCursorParams struct {
	CreatedAt pgtype.Timestamp
	Limit     int32
}

type GetNotificationsForOrdersAfterCursorRow struct {
	OrderID       uuid.UUID
	ReadableID    pgtype.Int8
	CreatedAt     pgtype.Timestamp
	WebAppID      pgtype.UUID
	Name          string
	Price         float64
	Quantity      int32
	PriceCurrency string
	Username      pgtype.Text
}

func (q *Queries) GetNotificationsForOrdersAfterCursor(ctx context.Context, arg GetNotificationsForOrdersAfterCursorParams) ([]GetNotificationsForOrdersAfterCursorRow, error) {
	rows, err := q.db.Query(ctx, getNotificationsForOrdersAfterCursor, arg.CreatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNotificationsForOrdersAfterCursorRow
	for rows.Next() {
		var i GetNotificationsForOrdersAfterCursorRow
		if err := rows.Scan(
			&i.OrderID,
			&i.ReadableID,
			&i.CreatedAt,
			&i.WebAppID,
			&i.Name,
			&i.Price,
			&i.Quantity,
			&i.PriceCurrency,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNotifierCursor = `-- name: GetNotifierCursor :one
select last_processed_created_at, last_processed_id
from notifier_cursors
where name = $1
`

type GetNotifierCursorRow struct {
	LastProcessedCreatedAt pgtype.Timestamp
	LastProcessedID        pgtype.UUID
}

func (q *Queries) GetNotifierCursor(ctx context.Context, name pgtype.Text) (GetNotifierCursorRow, error) {
	row := q.db.QueryRow(ctx, getNotifierCursor, name)
	var i GetNotifierCursorRow
	err := row.Scan(&i.LastProcessedCreatedAt, &i.LastProcessedID)
	return i, err
}

const updateNotifierCursor = `-- name: UpdateNotifierCursor :exec
update notifier_cursors
set last_processed_created_at = $2,
    last_processed_id         = $3
where name = $1
`

type UpdateNotifierCursorParams struct {
	Name                   pgtype.Text
	LastProcessedCreatedAt pgtype.Timestamp
	LastProcessedID        pgtype.UUID
}

func (q *Queries) UpdateNotifierCursor(ctx context.Context, arg UpdateNotifierCursorParams) error {
	_, err := q.db.Exec(ctx, updateNotifierCursor, arg.Name, arg.LastProcessedCreatedAt, arg.LastProcessedID)
	return err
}
