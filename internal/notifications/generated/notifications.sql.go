// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: notifications.sql

package generated

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addUserToNewOrderNotifications = `-- name: AddUserToNewOrderNotifications :exec
insert into new_order_notifications_list (web_app_id, admin_chat_id)
values ($1,
        $2)
`

type AddUserToNewOrderNotificationsParams struct {
	WebAppID    pgtype.UUID
	AdminChatID int64
}

func (q *Queries) AddUserToNewOrderNotifications(ctx context.Context, arg AddUserToNewOrderNotificationsParams) error {
	_, err := q.db.Exec(ctx, addUserToNewOrderNotifications, arg.WebAppID, arg.AdminChatID)
	return err
}

const getAdminsNotificationList = `-- name: GetAdminsNotificationList :many
with admins_batch as (select admin_chat_id
                      from new_order_notifications_list
                      where web_app_id = $1)
select ab.admin_chat_id,
       u.language_code
from admins_batch ab
         join telegram_users u on ab.admin_chat_id = u.external_id
`

type GetAdminsNotificationListRow struct {
	AdminChatID  int64
	LanguageCode pgtype.Text
}

func (q *Queries) GetAdminsNotificationList(ctx context.Context, webAppID pgtype.UUID) ([]GetAdminsNotificationListRow, error) {
	rows, err := q.db.Query(ctx, getAdminsNotificationList, webAppID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAdminsNotificationListRow
	for rows.Next() {
		var i GetAdminsNotificationListRow
		if err := rows.Scan(&i.AdminChatID, &i.LanguageCode); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNotificationsForNewMarketplacesAfterCursor = `-- name: GetNotificationsForNewMarketplacesAfterCursor :many
with marketplaces_batch as (select wa.id,
                                   wa.name,
                                   wa.short_name,
                                   wa.created_at,
                                   wa.owner_external_id
                            from web_apps wa
                            where wa.is_verified = false
                              and (wa.created_at, wa.id) > ($2::timestamp, $3::uuid)
                            order by wa.created_at, wa.id
                            limit $1)
select mb.id,
       mb.name,
       mb.short_name,
       mb.created_at,
       u.username,
       u.language_code,
       u.external_id as owner_external_id
from marketplaces_batch mb
         join telegram_users u
              on mb.owner_external_id = u.external_id
order by mb.created_at, mb.id
`

type GetNotificationsForNewMarketplacesAfterCursorParams struct {
	Limit     int32
	CreatedAt pgtype.Timestamp
	ID        uuid.UUID
}

type GetNotificationsForNewMarketplacesAfterCursorRow struct {
	ID              uuid.UUID
	Name            string
	ShortName       string
	CreatedAt       pgtype.Timestamp
	Username        pgtype.Text
	LanguageCode    pgtype.Text
	OwnerExternalID int64
}

func (q *Queries) GetNotificationsForNewMarketplacesAfterCursor(ctx context.Context, arg GetNotificationsForNewMarketplacesAfterCursorParams) ([]GetNotificationsForNewMarketplacesAfterCursorRow, error) {
	rows, err := q.db.Query(ctx, getNotificationsForNewMarketplacesAfterCursor, arg.Limit, arg.CreatedAt, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNotificationsForNewMarketplacesAfterCursorRow
	for rows.Next() {
		var i GetNotificationsForNewMarketplacesAfterCursorRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ShortName,
			&i.CreatedAt,
			&i.Username,
			&i.LanguageCode,
			&i.OwnerExternalID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNotificationsForUpdatedOrders = `-- name: GetNotificationsForUpdatedOrders :many
with orders_batch as (select id as order_id,
                             created_at,
                             readable_id,
                             external_user_id,
                             state,
                             type,
                             web_app_id
                      from orders o
                      where (o.updated_at, o.id) > ($2::timestamp, $3::uuid)
                      order by o.updated_at, o.id
                      limit $1)
select orders_batch.order_id    as order_id,
       orders_batch.readable_id as readable_id,
       orders_batch.created_at  as created_at,
       orders_batch.state::text as state,
       orders_batch.web_app_id  as web_app_id,
       wa.name                  as web_app_name,
       coalesce(
               json_agg(json_build_object(
                       'id', p.id,
                       'name', p.name,
                       'quantity', op.quantity,
                       'price', p.price
                        )
               ),
               '[]'::json
       ) ::json                 as products,
       wa.currency              as currency,
       u.username               as buyer_username,
       u.language_code          as buyer_language_code,
       u.external_id            as buyer_external_user_id,
       adm.language_code        as admin_language_code,
       orders_batch.state::text as state,
       orders_batch.type::text  as payment_type
from orders_batch
         join order_products op
              on orders_batch.order_id = op.order_id
         join products p on p.id = op.product_id
         join telegram_users u on external_user_id = u.external_id
         join web_apps wa on orders_batch.web_app_id = wa.id
         join telegram_users adm on wa.owner_external_id = adm.external_id
group by orders_batch.order_id, orders_batch.readable_id, orders_batch.created_at, orders_batch.state::text,
         orders_batch.web_app_id, wa.name,
         wa.currency, op.quantity, u.username, u.language_code, u.external_id, adm.language_code,
         orders_batch.state::text,
         orders_batch.type::text
`

type GetNotificationsForUpdatedOrdersParams struct {
	Limit     int32
	UpdatedAt pgtype.Timestamp
	ID        uuid.UUID
}

type GetNotificationsForUpdatedOrdersRow struct {
	OrderID             uuid.UUID
	ReadableID          pgtype.Int8
	CreatedAt           pgtype.Timestamp
	State               string
	WebAppID            pgtype.UUID
	WebAppName          string
	Products            []byte
	Currency            ProductCurrency
	BuyerUsername       pgtype.Text
	BuyerLanguageCode   pgtype.Text
	BuyerExternalUserID int64
	AdminLanguageCode   pgtype.Text
	State_2             string
	PaymentType         string
}

func (q *Queries) GetNotificationsForUpdatedOrders(ctx context.Context, arg GetNotificationsForUpdatedOrdersParams) ([]GetNotificationsForUpdatedOrdersRow, error) {
	rows, err := q.db.Query(ctx, getNotificationsForUpdatedOrders, arg.Limit, arg.UpdatedAt, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNotificationsForUpdatedOrdersRow
	for rows.Next() {
		var i GetNotificationsForUpdatedOrdersRow
		if err := rows.Scan(
			&i.OrderID,
			&i.ReadableID,
			&i.CreatedAt,
			&i.State,
			&i.WebAppID,
			&i.WebAppName,
			&i.Products,
			&i.Currency,
			&i.BuyerUsername,
			&i.BuyerLanguageCode,
			&i.BuyerExternalUserID,
			&i.AdminLanguageCode,
			&i.State_2,
			&i.PaymentType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNotificationsForVerifiedMarketplacesAfterCursor = `-- name: GetNotificationsForVerifiedMarketplacesAfterCursor :many
with marketplaces_batch as (select wa.id,
                                   wa.name,
                                   wa.short_name,
                                   wa.verified_at,
                                   wa.owner_external_id
                            from web_apps wa
                            where wa.is_verified = true
                              and (wa.verified_at, wa.id) > ($2::timestamp, $3::uuid)
                            order by wa.verified_at, wa.id
                            limit $1)
select mb.id,
       mb.name,
       mb.short_name,
       mb.verified_at,
       mb.owner_external_id,
       u.language_code
from marketplaces_batch mb
         join telegram_users u on mb.owner_external_id = u.external_id
order by mb.verified_at, mb.id
`

type GetNotificationsForVerifiedMarketplacesAfterCursorParams struct {
	Limit      int32
	VerifiedAt pgtype.Timestamp
	ID         uuid.UUID
}

type GetNotificationsForVerifiedMarketplacesAfterCursorRow struct {
	ID              uuid.UUID
	Name            string
	ShortName       string
	VerifiedAt      pgtype.Timestamp
	OwnerExternalID pgtype.Int8
	LanguageCode    pgtype.Text
}

func (q *Queries) GetNotificationsForVerifiedMarketplacesAfterCursor(ctx context.Context, arg GetNotificationsForVerifiedMarketplacesAfterCursorParams) ([]GetNotificationsForVerifiedMarketplacesAfterCursorRow, error) {
	rows, err := q.db.Query(ctx, getNotificationsForVerifiedMarketplacesAfterCursor, arg.Limit, arg.VerifiedAt, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNotificationsForVerifiedMarketplacesAfterCursorRow
	for rows.Next() {
		var i GetNotificationsForVerifiedMarketplacesAfterCursorRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ShortName,
			&i.VerifiedAt,
			&i.OwnerExternalID,
			&i.LanguageCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNotifierCursor = `-- name: GetNotifierCursor :one
select cursor_date, last_processed_id
from notifier_cursors
where name = $1
`

type GetNotifierCursorRow struct {
	CursorDate      pgtype.Timestamp
	LastProcessedID pgtype.UUID
}

func (q *Queries) GetNotifierCursor(ctx context.Context, name pgtype.Text) (GetNotifierCursorRow, error) {
	row := q.db.QueryRow(ctx, getNotifierCursor, name)
	var i GetNotifierCursorRow
	err := row.Scan(&i.CursorDate, &i.LastProcessedID)
	return i, err
}

const getProductCustomMediaForward = `-- name: GetProductCustomMediaForward :one
select from_chat_id, message_id
from product_custom_media_forwards
where product_id = $1
  and on_order_state = $2
order by created_at desc
limit 1
`

type GetProductCustomMediaForwardParams struct {
	ProductID    uuid.UUID
	OnOrderState OrderState
}

type GetProductCustomMediaForwardRow struct {
	FromChatID int64
	MessageID  int64
}

func (q *Queries) GetProductCustomMediaForward(ctx context.Context, arg GetProductCustomMediaForwardParams) (GetProductCustomMediaForwardRow, error) {
	row := q.db.QueryRow(ctx, getProductCustomMediaForward, arg.ProductID, arg.OnOrderState)
	var i GetProductCustomMediaForwardRow
	err := row.Scan(&i.FromChatID, &i.MessageID)
	return i, err
}

const getProductCustomMessage = `-- name: GetProductCustomMessage :one
select message
from products_custom_messages
where product_id = $1
  and on_order_state = $2
order by created_at desc
limit 1
`

type GetProductCustomMessageParams struct {
	ProductID    uuid.UUID
	OnOrderState OrderState
}

func (q *Queries) GetProductCustomMessage(ctx context.Context, arg GetProductCustomMessageParams) (string, error) {
	row := q.db.QueryRow(ctx, getProductCustomMessage, arg.ProductID, arg.OnOrderState)
	var message string
	err := row.Scan(&message)
	return message, err
}

const getReviewersNotificationList = `-- name: GetReviewersNotificationList :many
select chat_id
from new_web_apps_notifications_list
`

func (q *Queries) GetReviewersNotificationList(ctx context.Context) ([]int64, error) {
	rows, err := q.db.Query(ctx, getReviewersNotificationList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var chat_id int64
		if err := rows.Scan(&chat_id); err != nil {
			return nil, err
		}
		items = append(items, chat_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateNotifierCursor = `-- name: UpdateNotifierCursor :exec
update notifier_cursors
set cursor_date       = $2,
    last_processed_id = $3
where name = $1
`

type UpdateNotifierCursorParams struct {
	Name            pgtype.Text
	CursorDate      pgtype.Timestamp
	LastProcessedID pgtype.UUID
}

func (q *Queries) UpdateNotifierCursor(ctx context.Context, arg UpdateNotifierCursorParams) error {
	_, err := q.db.Exec(ctx, updateNotifierCursor, arg.Name, arg.CursorDate, arg.LastProcessedID)
	return err
}
