// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: notifications.sql

package generated

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addUserToNewOrderNotifications = `-- name: AddUserToNewOrderNotifications :exec
insert into new_order_notifications_list (web_app_id, admin_chat_id)
values ($1,
        $2)
`

type AddUserToNewOrderNotificationsParams struct {
	WebAppID    pgtype.UUID
	AdminChatID int64
}

func (q *Queries) AddUserToNewOrderNotifications(ctx context.Context, arg AddUserToNewOrderNotificationsParams) error {
	_, err := q.db.Exec(ctx, addUserToNewOrderNotifications, arg.WebAppID, arg.AdminChatID)
	return err
}

const getAdminsNotificationList = `-- name: GetAdminsNotificationList :many
with admins_batch as (select admin_chat_id
	 			  	  from new_order_notifications_list
					  where web_app_id = $1)
select ab.admin_chat_id,
	   u.language_code
from admins_batch ab
	 join telegram_users u on ab.admin_chat_id = u.external_id
`

type GetAdminsNotificationListRow struct {
	AdminChatID  int64
	LanguageCode pgtype.Text
}

func (q *Queries) GetAdminsNotificationList(ctx context.Context, webAppID pgtype.UUID) ([]GetAdminsNotificationListRow, error) {
	rows, err := q.db.Query(ctx, getAdminsNotificationList, webAppID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAdminsNotificationListRow
	for rows.Next() {
		var i GetAdminsNotificationListRow
		if err := rows.Scan(&i.AdminChatID, &i.LanguageCode); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNotificationsForNewMarketplacesAfterCursor = `-- name: GetNotificationsForNewMarketplacesAfterCursor :many
with marketplaces_batch as (select wa.id,
                                   wa.name,
                                   wa.short_name,
                                   wa.created_at,
                                   wa.owner_external_id
                            from web_apps wa
                            where wa.is_verified = false
                              and (wa.created_at, wa.id) > ($2::timestamp, $3::uuid)
                            order by wa.created_at, wa.id
                            limit $1)
select mb.id,
       mb.name,
       mb.short_name,
       mb.created_at,
       u.username,
	   u.language_code,
       u.external_id as owner_external_id
from marketplaces_batch mb
         join telegram_users u
              on mb.owner_external_id = u.external_id
order by mb.created_at, mb.id
`

type GetNotificationsForNewMarketplacesAfterCursorParams struct {
	Limit     int32
	CreatedAt pgtype.Timestamp
	ID        uuid.UUID
}

type GetNotificationsForNewMarketplacesAfterCursorRow struct {
	ID              uuid.UUID
	Name            string
	ShortName       string
	CreatedAt       pgtype.Timestamp
	Username        pgtype.Text
	LanguageCode    pgtype.Text
	OwnerExternalID int32
}

func (q *Queries) GetNotificationsForNewMarketplacesAfterCursor(ctx context.Context, arg GetNotificationsForNewMarketplacesAfterCursorParams) ([]GetNotificationsForNewMarketplacesAfterCursorRow, error) {
	rows, err := q.db.Query(ctx, getNotificationsForNewMarketplacesAfterCursor, arg.Limit, arg.CreatedAt, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNotificationsForNewMarketplacesAfterCursorRow
	for rows.Next() {
		var i GetNotificationsForNewMarketplacesAfterCursorRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ShortName,
			&i.CreatedAt,
			&i.Username,
			&i.LanguageCode,
			&i.OwnerExternalID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNotificationsForNewOrdersAfterCursor = `-- name: GetNotificationsForNewOrdersAfterCursor :many
with orders_batch as (select id as order_id, created_at, readable_id, web_app_id, external_user_id, state, type
                      from orders o
                      where (o.updated_at, o.id) > ($2::timestamp, $3::uuid)
                        and o.state = 'confirmed'
                      order by o.created_at, o.id
                      limit $1)
select ob.order_id,
       ob.readable_id,
       ob.created_at,
	   ob.state::text,
       p.web_app_id,
       wa.name       as web_app_name,
       p.name,
       p.price,
       p.price_currency,
       op.quantity,
       u.username,
	   u.language_code,
       u.external_id as external_user_id,
       adm.language_code as admin_language_code,
       ob.state::text as state,
	   ob.type::text as payment_type
from orders_batch ob
         join order_products op
              on ob.order_id = op.order_id
         join products p on p.id = op.product_id
         join telegram_users u on external_user_id = u.external_id
         join web_apps wa on ob.web_app_id = wa.id
         join telegram_users adm on wa.owner_external_id = adm.external_id
where ob.state = 'confirmed'
order by ob.created_at, ob.order_id
`

type GetNotificationsForNewOrdersAfterCursorParams struct {
	Limit     int32
	UpdatedAt pgtype.Timestamp
	ID        uuid.UUID
}

type GetNotificationsForNewOrdersAfterCursorRow struct {
	OrderID           uuid.UUID
	ReadableID        pgtype.Int8
	CreatedAt         pgtype.Timestamp
	ObState           string
	WebAppID          pgtype.UUID
	WebAppName        string
	Name              string
	Price             float64
	PriceCurrency     ProductCurrency
	Quantity          int32
	Username          pgtype.Text
	LanguageCode      pgtype.Text
	ExternalUserID    int32
	AdminLanguageCode pgtype.Text
	State             string
	PaymentType       string
}

func (q *Queries) GetNotificationsForNewOrdersAfterCursor(ctx context.Context, arg GetNotificationsForNewOrdersAfterCursorParams) ([]GetNotificationsForNewOrdersAfterCursorRow, error) {
	rows, err := q.db.Query(ctx, getNotificationsForNewOrdersAfterCursor, arg.Limit, arg.UpdatedAt, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNotificationsForNewOrdersAfterCursorRow
	for rows.Next() {
		var i GetNotificationsForNewOrdersAfterCursorRow
		if err := rows.Scan(
			&i.OrderID,
			&i.ReadableID,
			&i.CreatedAt,
			&i.ObState,
			&i.WebAppID,
			&i.WebAppName,
			&i.Name,
			&i.Price,
			&i.PriceCurrency,
			&i.Quantity,
			&i.Username,
			&i.LanguageCode,
			&i.ExternalUserID,
			&i.AdminLanguageCode,
			&i.State,
			&i.PaymentType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNotificationsForVerifiedMarketplacesAfterCursor = `-- name: GetNotificationsForVerifiedMarketplacesAfterCursor :many
with marketplaces_batch as (select wa.id,
                                   wa.name,
                                   wa.short_name,
                                   wa.verified_at,
                                   wa.owner_external_id
                            from web_apps wa
                            where wa.is_verified = true
                              and (wa.verified_at, wa.id) > ($2::timestamp, $3::uuid)
                            order by wa.verified_at, wa.id
                            limit $1)
select mb.id,
       mb.name,
       mb.short_name,
       mb.verified_at,
       mb.owner_external_id,
	   u.language_code
from marketplaces_batch mb
	 join telegram_users u on mb.owner_external_id = u.external_id
order by mb.verified_at, mb.id
`

type GetNotificationsForVerifiedMarketplacesAfterCursorParams struct {
	Limit      int32
	VerifiedAt pgtype.Timestamp
	ID         uuid.UUID
}

type GetNotificationsForVerifiedMarketplacesAfterCursorRow struct {
	ID              uuid.UUID
	Name            string
	ShortName       string
	VerifiedAt      pgtype.Timestamp
	OwnerExternalID pgtype.Int4
	LanguageCode    pgtype.Text
}

func (q *Queries) GetNotificationsForVerifiedMarketplacesAfterCursor(ctx context.Context, arg GetNotificationsForVerifiedMarketplacesAfterCursorParams) ([]GetNotificationsForVerifiedMarketplacesAfterCursorRow, error) {
	rows, err := q.db.Query(ctx, getNotificationsForVerifiedMarketplacesAfterCursor, arg.Limit, arg.VerifiedAt, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNotificationsForVerifiedMarketplacesAfterCursorRow
	for rows.Next() {
		var i GetNotificationsForVerifiedMarketplacesAfterCursorRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ShortName,
			&i.VerifiedAt,
			&i.OwnerExternalID,
			&i.LanguageCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNotifierCursor = `-- name: GetNotifierCursor :one
select cursor_date, last_processed_id
from notifier_cursors
where name = $1
`

type GetNotifierCursorRow struct {
	CursorDate      pgtype.Timestamp
	LastProcessedID pgtype.UUID
}

func (q *Queries) GetNotifierCursor(ctx context.Context, name pgtype.Text) (GetNotifierCursorRow, error) {
	row := q.db.QueryRow(ctx, getNotifierCursor, name)
	var i GetNotifierCursorRow
	err := row.Scan(&i.CursorDate, &i.LastProcessedID)
	return i, err
}

const getReviewersNotificationList = `-- name: GetReviewersNotificationList :many
select chat_id
from new_web_apps_notifications_list
`

func (q *Queries) GetReviewersNotificationList(ctx context.Context) ([]int64, error) {
	rows, err := q.db.Query(ctx, getReviewersNotificationList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var chat_id int64
		if err := rows.Scan(&chat_id); err != nil {
			return nil, err
		}
		items = append(items, chat_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateNotifierCursor = `-- name: UpdateNotifierCursor :exec
update notifier_cursors
set cursor_date       = $2,
    last_processed_id = $3
where name = $1
`

type UpdateNotifierCursorParams struct {
	Name            pgtype.Text
	CursorDate      pgtype.Timestamp
	LastProcessedID pgtype.UUID
}

func (q *Queries) UpdateNotifierCursor(ctx context.Context, arg UpdateNotifierCursorParams) error {
	_, err := q.db.Exec(ctx, updateNotifierCursor, arg.Name, arg.CursorDate, arg.LastProcessedID)
	return err
}
