// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: orders.sql

package generated

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getOrders = `-- name: GetOrders :many
SELECT o.id                       AS id,
       o.web_app_id               AS marketplace_id,
       o.readable_id              AS readable_id,
       o.state                    AS state,
       o.created_at               AS created_at,
       o.updated_at               AS updated_at,
       wa.currency                AS currency,
       (SELECT SUM(p.price * op.quantity)
        FROM order_products op
                 JOIN products p ON p.id = op.product_id
        WHERE op.order_id = o.id) AS total_price,
       tu.username                AS buyer_username,
       (SELECT json_agg(
                       json_build_object(
                               'id', p.id,
                               'name', p.name,
                               'quantity', op.quantity,
                               'price', p.price
                       )
               )
        FROM order_products op
                 JOIN products p ON p.id = op.product_id
        WHERE op.order_id = o.id) AS products
FROM orders o
         JOIN
     telegram_users tu ON tu.external_id = o.external_user_id
         join web_apps wa on wa.id = o.web_app_id
where tu.external_id = $3::integer
  and wa.owner_external_id = $3::integer
  and (
    case when $4 != '' then state = $4::order_state else true end
    )
  and (
    case
        when $5 != '00000000-0000-0000-0000-000000000000' then web_app_id = $5::uuid
        else true end
    )
order by o.created_at desc
limit $1 offset $2
`

type GetOrdersParams struct {
	Limit           int32
	Offset          int32
	OwnerExternalID int32
	State           interface{}
	MarketplaceID   interface{}
}

type GetOrdersRow struct {
	ID            uuid.UUID
	MarketplaceID pgtype.UUID
	ReadableID    pgtype.Int8
	State         OrderState
	CreatedAt     pgtype.Timestamp
	UpdatedAt     pgtype.Timestamp
	Currency      ProductCurrency
	TotalPrice    int64
	BuyerUsername pgtype.Text
	Products      []byte
}

func (q *Queries) GetOrders(ctx context.Context, arg GetOrdersParams) ([]GetOrdersRow, error) {
	rows, err := q.db.Query(ctx, getOrders,
		arg.Limit,
		arg.Offset,
		arg.OwnerExternalID,
		arg.State,
		arg.MarketplaceID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrdersRow
	for rows.Next() {
		var i GetOrdersRow
		if err := rows.Scan(
			&i.ID,
			&i.MarketplaceID,
			&i.ReadableID,
			&i.State,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Currency,
			&i.TotalPrice,
			&i.BuyerUsername,
			&i.Products,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
