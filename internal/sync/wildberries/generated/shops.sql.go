// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: shops.sql

package generated

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getNextShop = `-- name: GetNextShop :one
select id, web_app_id, api_key
from shop_external_connections
where is_active = true
  and external_provider = 'wildberries'::external_provider
  -- default value for the frequence of syncs
  and coalesce(last_sync_at, '1970-01-01'::timestamp) < now() - interval '1 hour'
  -- if the last sync was a failure, we wait 3 hours before retrying
  and coalesce(last_failure_at, '1970-01-01'::timestamp) < now() - interval '3 hour'
order by last_sync_at
limit 1
`

type GetNextShopRow struct {
	ID       uuid.UUID
	WebAppID uuid.UUID
	ApiKey   string
}

func (q *Queries) GetNextShop(ctx context.Context) (GetNextShopRow, error) {
	row := q.db.QueryRow(ctx, getNextShop)
	var i GetNextShopRow
	err := row.Scan(&i.ID, &i.WebAppID, &i.ApiKey)
	return i, err
}

const setSyncFailure = `-- name: SetSyncFailure :exec
update shop_external_connections
set last_failure_at  = now(),
    last_sync_status = 'failure'::extenal_sync_status,
    last_error       = $2
where id = $1
`

type SetSyncFailureParams struct {
	ID        uuid.UUID
	LastError pgtype.Text
}

func (q *Queries) SetSyncFailure(ctx context.Context, arg SetSyncFailureParams) error {
	_, err := q.db.Exec(ctx, setSyncFailure, arg.ID, arg.LastError)
	return err
}

const setSyncSuccess = `-- name: SetSyncSuccess :exec
update shop_external_connections
set last_sync_at     = now(),
    last_sync_status = 'success'::extenal_sync_status
where id = $1
`

func (q *Queries) SetSyncSuccess(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, setSyncSuccess, id)
	return err
}
